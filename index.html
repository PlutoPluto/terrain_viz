<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Web 3D åœ°å½¢å¯è§†åŒ–ç³»ç»Ÿ (ç»ˆæç‰ˆ)</title>
    <!-- å¼•å…¥ Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        /* === å…¨å±€æ ·å¼ === */
        body { margin: 0; padding: 0; font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif; overflow: hidden; background: #f0f2f5; }
        
        /* === å·¦ä¸Šè§’æ§åˆ¶é¢æ¿ === */
        #control-panel {
            position: absolute; top: 20px; left: 20px; z-index: 999;
            background: rgba(255,255,255,0.95); /* æ¯›ç»ç’ƒæ•ˆæœ */
            padding: 20px; width: 280px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.12);
            backdrop-filter: blur(8px);
            display: flex; flex-direction: column; gap: 15px;
            transition: transform 0.3s ease;
        }

        /* æ ‡é¢˜ä¸åˆ†å‰²çº¿ */
        h3 { margin: 0; font-size: 16px; color: #333; border-left: 4px solid #007bff; padding-left: 10px; }
        hr { border: 0; border-top: 1px solid #eee; width: 100%; margin: 0; }

        /* æ§ä»¶è¡Œå¸ƒå±€ */
        .control-row { display: flex; flex-direction: column; gap: 6px; font-size: 13px; color: #555; }
        .row-flex { display: flex; justify-content: space-between; align-items: center; }
        
        /* æŒ‰é’®æ ·å¼ */
        .btn {
            padding: 10px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 13px; font-weight: 600; color: white; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn-primary { background: #007bff; }
        .btn-primary:hover { background: #0056b3; transform: translateY(-1px); }
        
        .btn-download { background: #28a745; }
        .btn-download:hover { background: #218838; transform: translateY(-1px); }
        
        .btn-outline {
            background: white; border: 1px solid #007bff; color: #007bff; padding: 4px 8px; font-size: 11px;
        }
        .btn-outline:hover { background: #f0f8ff; }

        .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }

        /* æ»‘åŠ¨æ¡ */
        input[type="range"] { width: 100%; cursor: pointer; margin-top: 5px; }
        input[type="checkbox"] { cursor: pointer; width: 16px; height: 16px; }

        /* === ä¸»è§†å›¾å®¹å™¨ === */
        #main { width: 100vw; height: 100vh; }

        /* === éšè—å®¹å™¨ (ç”¨äºåå°ç”Ÿæˆå›¾ç‰‡) === */
        #hidden-canvas {
            position: fixed; top: 0; left: -9999px;
            width: 2000px; height: 2000px; 
            visibility: hidden; pointer-events: none;
        }

        /* === åŠ è½½åŠ¨ç”»é®ç½© === */
        #loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); z-index: 1000;
            display: none; justify-content: center; align-items: center; color: white;
            flex-direction: column; font-size: 15px;
        }
        .spinner {
            width: 36px; height: 36px; border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid #fff; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- åŠ è½½å±‚ -->
    <div id="loading-mask">
        <div class="spinner"></div>
        <div id="loading-text">å¤„ç†ä¸­...</div>
    </div>

    <!-- æ‚¬æµ®æ§åˆ¶é¢æ¿ -->
    <div id="control-panel">
        <h3>åœ°å½¢å¯è§†åŒ–ç³»ç»Ÿ</h3>

        <!-- 1. å¯¼å…¥æ•°æ® -->
        <div class="control-row">
            <input type="file" id="fileInput" accept=".txt,.csv,.dat" style="display:none">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                ğŸ“‚ å¯¼å…¥æ•°æ® (XYZ)
            </button>
        </div>

        <hr>

        <!-- 2. Zè½´å¤¸å¼ æ§åˆ¶ -->
        <div class="control-row">
            <div class="row-flex">
                <span>Zè½´å¤¸å¼ ç³»æ•°</span>
                <!-- ä¸€é”®æ¢å¤çœŸå®æ¯”ä¾‹æŒ‰é’® -->
                <button class="btn btn-outline" onclick="resetTrueScale()" title="æ ¹æ®æ•°æ®èŒƒå›´è®¡ç®—çœŸå®çš„ç‰©ç†æ¯”ä¾‹">
                    æ¢å¤ 1:1 çœŸå®æ¯”ä¾‹
                </button>
            </div>
            <div class="row-flex" style="margin-top:2px;">
                <span style="font-size:11px; color:#999;">å€¼: <span id="zScaleVal" style="color:#333; font-weight:bold;">0.5</span></span>
            </div>
            <input type="range" id="zScale" min="0.01" max="5.0" step="0.01" value="0.5">
        </div>

        <!-- 3. æ˜¾ç¤ºé£æ ¼ -->
        <div class="control-row">
            <div class="row-flex">
                <label for="chkFlat" style="cursor:pointer;">ç¡¬æœ—ä¸‰è§’é¢ (Flat Shading)</label>
                <input type="checkbox" id="chkFlat" checked>
            </div>
        </div>

        <hr>

        <!-- 4. ä¸‹è½½ä¿¯è§†å›¾ -->
        <div class="control-row">
            <button class="btn btn-download" id="btnDownload" disabled onclick="downloadContourMap()">
                â¬‡ï¸ ä¸‹è½½ç­‰é«˜çº¿ä¿¯è§†å›¾
            </button>
            <div style="font-size:11px; color:#888; line-height:1.4;">
                * ç”Ÿæˆé«˜æ¸…å›¾ (PNG)<br>
                * æ— åæ ‡è½´ï¼Œå«å³ä¾§æ•°å€¼å›¾ä¾‹
            </div>
        </div>
    </div>

    <!-- 3D ä¸»ç»˜å›¾åŒº -->
    <div id="main"></div>

    <!-- å¹•åç»˜å›¾åŒº -->
    <div id="hidden-canvas"></div>

    <script>
        // === å…¨å±€çŠ¶æ€ ===
        let globalRawData = null;
        let aspectXY = { x: 1, y: 1 };
        let trueZRatio = 0.1; // çœŸå®æ¯”ä¾‹ç³»æ•°

        // === DOM å¼•ç”¨ ===
        const zScaleInput = document.getElementById('zScale');
        const zScaleText = document.getElementById('zScaleVal');
        const chkFlat = document.getElementById('chkFlat');
        const loadingMask = document.getElementById('loading-mask');
        const loadingText = document.getElementById('loading-text');

        // === äº‹ä»¶ç›‘å¬ ===
        
        // 1. æ–‡ä»¶å¯¼å…¥
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            showLoading("æ­£åœ¨è§£ææ•°æ®...");
            setTimeout(() => {
                const reader = new FileReader();
                reader.onload = (event) => processData(event.target.result);
                reader.readAsText(file);
            }, 50);
        });

        // 2. æ»‘å—æ‹–åŠ¨
        zScaleInput.addEventListener('input', function(e) {
            zScaleText.innerText = e.target.value;
            update3DView();
        });

        // 3. é£æ ¼åˆ‡æ¢
        chkFlat.addEventListener('change', update3DView);

        // === æ ¸å¿ƒé€»è¾‘ ===

        // å¤„ç†æ•°æ®
        function processData(text) {
            const lines = text.split('\n');
            const points = [];
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            lines.forEach(line => {
                const parts = line.trim().split(/[\s,]+/);
                if (parts.length >= 3) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    const z = parseFloat(parts[2]);
                    if (!isNaN(x)) {
                        points.push({x, y, z});
                        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                        minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
                    }
                }
            });

            if (points.length === 0) {
                alert("æœªæ‰¾åˆ°æœ‰æ•ˆæ•°æ®ï¼è¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ã€‚"); hideLoading(); return;
            }

            // è®¡ç®—å‡ ä½•å°ºå¯¸
            const width = maxX - minX;
            const height = maxY - minY;
            const elevation = maxZ - minZ;
            const maxDim = Math.max(width, height);

            // è®¡ç®—åŸºç¡€ XY æ¯”ä¾‹ (å½’ä¸€åŒ–)
            aspectXY = { x: width / maxDim, y: height / maxDim };

            // ã€å…³é”®ã€‘è®¡ç®— 1:1 æ—¶çš„ Z è½´æ¯”ä¾‹
            // å¦‚æœ Z èŒƒå›´æ˜¯ 0ï¼Œé˜²æ­¢é™¤ä»¥0é”™è¯¯ï¼Œç»™ä¸€ä¸ªé»˜è®¤æå°å€¼
            trueZRatio = (elevation > 0) ? (elevation / maxDim) : 0.01;

            // ä¿å­˜æ•°æ®
            globalRawData = { points, minX, maxX, minY, maxY, width, height, minZ, maxZ };

            // æ¸²æŸ“
            render3DTIN();
            
            // æ¿€æ´»æŒ‰é’®
            document.getElementById('btnDownload').disabled = false;
            hideLoading();
        }

        // æ¸²æŸ“ 3D ä¸‰è§’ç½‘
        function render3DTIN() {
            const p = globalRawData.points;
            const currentZScale = parseFloat(zScaleInput.value);
            const isFlat = chkFlat.checked;

            const trace = {
                type: 'mesh3d',
                x: p.map(pt => pt.x),
                y: p.map(pt => pt.y),
                z: p.map(pt => pt.z),
                delaunayaxis: 'z', // æ ¸å¿ƒï¼šåŸºäº Z è½´æŠ•å½±è¿›è¡Œä¸‰è§’å‰–åˆ†
                intensity: p.map(pt => pt.z),
                colorscale: 'Earth',
                flatshading: isFlat, // ç¡¬æœ—/å¹³æ»‘åˆ‡æ¢
                lighting: { ambient: 0.5, diffuse: 0.8, roughness: 0.1 }
            };

            const layout = {
                margin: { l:0, r:0, b:0, t:0 },
                scene: {
                    aspectmode: 'manual',
                    aspectratio: { 
                        x: aspectXY.x, 
                        y: aspectXY.y, 
                        z: currentZScale 
                    },
                    xaxis: { title: 'X' },
                    yaxis: { title: 'Y' },
                    zaxis: { title: 'Height' },
                    camera: { eye: {x: 1.2, y: 1.2, z: 1.2} }
                }
            };

            Plotly.newPlot('main', [trace], layout, {responsive: true, displayModeBar: false});
        }

        // æ›´æ–° 3D è§†å›¾å‚æ•° (ä¸é‡æ–°è§£ææ•°æ®)
        function update3DView() {
            if (!globalRawData) return;
            const currentZScale = parseFloat(zScaleInput.value);
            const isFlat = chkFlat.checked;

            Plotly.restyle('main', { flatshading: isFlat });
            Plotly.relayout('main', { 'scene.aspectratio.z': currentZScale });
        }

        // æ¢å¤ 1:1 çœŸå®æ¯”ä¾‹
        function resetTrueScale() {
            if (!globalRawData) return;
            // è®¾ç½®æ»‘å—
            zScaleInput.value = trueZRatio;
            zScaleText.innerText = trueZRatio.toFixed(3);
            // æ›´æ–°è§†å›¾
            update3DView();
        }

        // ä¸‹è½½ç­‰é«˜çº¿ä¿¯è§†å›¾
        function downloadContourMap() {
            const btn = document.getElementById('btnDownload');
            const originalText = btn.innerText;
            btn.innerText = "ç”Ÿæˆä¸­...";
            btn.disabled = true;
            showLoading("æ­£åœ¨ç”Ÿæˆé«˜ç²¾åº¦ç½‘æ ¼...");

            setTimeout(() => {
                // 1. æ’å€¼ç”Ÿæˆå¹³æ»‘ç½‘æ ¼ (IDWç®—æ³•)
                // åˆ†è¾¨ç‡è®¾ä¸º 200 ä»¥è·å¾—å¹³æ»‘æ›²çº¿
                const gridRes = 200; 
                const grid = generateGridIDW(globalRawData, gridRes);

                // 2. é…ç½® Contour å›¾å±‚
                const trace = {
                    type: 'contour',
                    z: grid.z, x: grid.x, y: grid.y,
                    colorscale: 'Earth',
                    
                    // å›¾ä¾‹è®¾ç½® (å¸¦æ•°å­—)
                    showscale: true,
                    colorbar: {
                        title: 'Height (m)',
                        titleside: 'right',
                        titlefont: { size: 16, family: 'Arial' },
                        tickfont: { size: 14, family: 'Arial' },
                        thickness: 30,
                        len: 0.9
                    },
                    
                    // ç­‰é«˜çº¿æ ‡ç­¾
                    contours: {
                        coloring: 'heatmap',
                        showlabels: true, // æ˜¾ç¤ºçº¿ä¸Šçš„æ•°å­—
                        labelfont: { size: 11, color: 'white' }
                    },
                    line: { width: 0.5, color: 'rgba(255,255,255,0.5)' }
                };

                // 3. é…ç½®å¸ƒå±€ (Layout)
                const cleanLayout = {
                    title: '', // æ— æ ‡é¢˜
                    // å³ä¾§ç•™å‡º 180px ç»™å›¾ä¾‹ï¼Œå…¶ä½™è¾¹è·ä¸º 0
                    margin: { l: 0, r: 180, b: 0, t: 0 }, 
                    xaxis: { 
                        visible: false, // éšè— X è½´
                        scaleanchor: 'y', scaleratio: 1 
                    },
                    yaxis: { 
                        visible: false  // éšè— Y è½´
                    },
                    paper_bgcolor: 'rgba(255,255,255,0)', // é€æ˜èƒŒæ™¯
                    plot_bgcolor: 'rgba(255,255,255,0)'
                };

                // 4. åœ¨éšè—ç”»å¸ƒç»˜å›¾å¹¶ä¸‹è½½
                Plotly.newPlot('hidden-canvas', [trace], cleanLayout).then(gd => {
                    // å¯¼å‡ºå°ºå¯¸è®¡ç®—
                    const exportWidth = 2500; // åŸºç¡€å®½åº¦
                    const mapHeight = exportWidth * (globalRawData.height / globalRawData.width);
                    
                    Plotly.downloadImage(gd, {
                        format: 'png',
                        // æœ€ç»ˆå®½åº¦ = åœ°å›¾å®½ + å›¾ä¾‹è¾¹è·
                        width: exportWidth + 180, 
                        height: mapHeight,
                        filename: 'contour_map_topview_hd'
                    }).then(() => {
                        btn.innerText = originalText;
                        btn.disabled = false;
                        hideLoading();
                    });
                });
            }, 100);
        }

        // è¾…åŠ©ç®—æ³•ï¼šIDW (åè·ç¦»åŠ æƒ) ç½‘æ ¼åŒ–
        function generateGridIDW(data, res) {
            const stepX = data.width / (res - 1);
            const stepY = data.height / (res - 1);
            const xArr = [], yArr = [], zMatrix = [];

            for (let i = 0; i < res; i++) {
                const cy = data.minY + i * stepY;
                yArr.push(cy);
                const row = [];
                for (let j = 0; j < res; j++) {
                    const cx = data.minX + j * stepX;
                    if (i === 0) xArr.push(cx);
                    
                    let num = 0, den = 0;
                    // ç®€å• IDW: éå†æ‰€æœ‰ç‚¹ (Power = 3)
                    // å¯¹äºæµ·é‡æ•°æ® (>5000ç‚¹) è¿™é‡Œå¯èƒ½ä¼šæ…¢ï¼Œå¯ä¼˜åŒ–ä¸ºåªå–æœ€è¿‘Nç‚¹
                    for (let p of data.points) {
                        const d2 = (cx - p.x)**2 + (cy - p.y)**2;
                        if (d2 < 1e-6) { num = p.z; den = 1; break; }
                        const w = 1 / (d2 * Math.sqrt(d2)); 
                        num += w * p.z; den += w;
                    }
                    row.push(num / den);
                }
                zMatrix.push(row);
            }
            return { x: xArr, y: yArr, z: zMatrix };
        }

        // UI å·¥å…·å‡½æ•°
        function showLoading(msg) {
            loadingText.innerText = msg;
            loadingMask.style.display = 'flex';
        }
        function hideLoading() {
            loadingMask.style.display = 'none';
        }
    </script>
</body>
</html>