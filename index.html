<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Web 3D åœ°å½¢ - TIN çº¿æ€§æ’å€¼ç‰ˆ</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <!-- D3 Delaunay åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6.0.4/dist/d3-delaunay.min.js"></script>
    
    <style>
        /* === æ ·å¼ä¿æŒä¸å˜ === */
        body { margin: 0; padding: 0; font-family: "Segoe UI", Roboto, sans-serif; overflow: hidden; background: #f0f2f5; }
        #control-panel {
            position: absolute; top: 20px; left: 20px; z-index: 999;
            background: rgba(255,255,255,0.95); padding: 20px; width: 280px;
            border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.12);
            backdrop-filter: blur(8px); display: flex; flex-direction: column; gap: 12px;
        }
        h3 { margin: 0; font-size: 16px; color: #333; border-left: 4px solid #007bff; padding-left: 10px; }
        hr { border: 0; border-top: 1px solid #eee; width: 100%; margin: 0; }
        .control-row { display: flex; flex-direction: column; gap: 6px; font-size: 13px; color: #555; }
        .row-flex { display: flex; justify-content: space-between; align-items: center; }
        .btn {
            padding: 10px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 13px; font-weight: 600; color: white; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn-primary { background: #007bff; }
        .btn-download { background: #28a745; }
        .btn-outline { background: white; border: 1px solid #007bff; color: #007bff; padding: 4px 8px; font-size: 11px; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        input[type="range"] { width: 100%; margin-top: 5px; }
        input[type="checkbox"] { cursor: pointer; width: 16px; height: 16px; }
        .number-input { width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 4px; text-align: center; }
        #main { width: 100vw; height: 100vh; }
        #hidden-canvas { position: fixed; top: 0; left: -9999px; visibility: hidden; pointer-events: none; }
        #loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); z-index: 1000; display: none; justify-content: center; align-items: center; color: white; font-size: 15px; flex-direction: column;
        }
    </style>
</head>
<body>

    <div id="loading-mask"><div id="loading-text">å¤„ç†ä¸­...</div></div>

    <div id="control-panel">
        <h3>åœ°å½¢å¯è§†åŒ–ç³»ç»Ÿ</h3>

        <div class="control-row">
            <input type="file" id="fileInput" accept=".txt,.csv,.dat" style="display:none">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">ğŸ“‚ å¯¼å…¥æ•°æ® (XYZ)</button>
        </div>
        <hr>
        <div class="control-row">
            <div class="row-flex">
                <span>Zè½´å¤¸å¼ </span>
                <button class="btn btn-outline" onclick="resetTrueScale()">æ¢å¤ 1:1</button>
            </div>
            <input type="range" id="zScale" min="0.01" max="5.0" step="0.01">
        </div>
        <div class="control-row">
            <div class="row-flex">
                <label for="chkFlat" style="cursor:pointer;">ç¡¬æœ—ä¸‰è§’é¢</label>
                <input type="checkbox" id="chkFlat">
            </div>
        </div>
        <hr>
        <div class="control-row">
            <div class="row-flex">
                <span title="è¾¹ç¼˜å‰¥èš€åŠ›åº¦">Alpha (å‰¥èš€)</span>
                <input type="number" id="alphaInput" class="number-input" value="0.02" step="0.01" min="0">
            </div>
            <div style="font-size:11px; color:#888; margin-top:4px;">
                * è¾¹ç¼˜å‰¥èš€ï¼Œä¿ç•™å†…éƒ¨<br>
                * 0 = å‡¸åŒ…
            </div>
        </div>
        <hr>
        <div class="control-row">
            <button class="btn btn-download" id="btnDownload" disabled onclick="downloadContourMap()">â¬‡ï¸ ä¸‹è½½ç­‰é«˜çº¿å›¾</button>
            <div style="font-size:11px; color:#888; line-height:1.4;">
                * <b>TIN çº¿æ€§æ’å€¼</b> (ç»å¯¹ç²¾å‡†)<br>
                * 5m ç­‰é«˜çº¿ï¼Œå›¾ä¾‹å¯¹é½
            </div>
        </div>
    </div>

    <div id="main"></div>
    <div id="hidden-canvas"></div>

    <script>
        let globalRawData = null;
        let aspectXY = { x: 1, y: 1 };
        let trueZRatio = 0.1;
        
        let globalDelaunay = null;
        let currentMeshIndices = null; // ä¿å­˜ I, J, K
        // æ³¨æ„ï¼šTINæ’å€¼ä¸éœ€è¦ boundaryPolygonï¼Œå› ä¸ºä¸‰è§’å½¢åˆ—è¡¨æœ¬èº«å°±å®šä¹‰äº†è¾¹ç•Œ

        const zScaleInput = document.getElementById('zScale');
        const chkFlat = document.getElementById('chkFlat');
        const alphaInput = document.getElementById('alphaInput');
        const loadingMask = document.getElementById('loading-mask');
        const loadingText = document.getElementById('loading-text');

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            showLoading("æ­£åœ¨è§£ææ•°æ®...");
            setTimeout(() => {
                const reader = new FileReader();
                reader.onload = (event) => processData(event.target.result);
                reader.readAsText(file);
            }, 50);
        });

        zScaleInput.addEventListener('input', () => update3DView(false));
        chkFlat.addEventListener('change', () => update3DView(false));
        
        let alphaDebounce;
        alphaInput.addEventListener('input', () => {
            clearTimeout(alphaDebounce);
            alphaDebounce = setTimeout(() => recalcAlphaMesh(), 300);
        });

        function processData(text) {
            const lines = text.split('\n');
            const points = [];
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity;

            lines.forEach(line => {
                const parts = line.trim().split(/[\s,]+/);
                if (parts.length >= 3) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    const z = parseFloat(parts[2]);
                    if (!isNaN(x)) {
                        points.push({x, y, z});
                        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                        minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
                    }
                }
            });

            if (points.length === 0) { alert("æ— æœ‰æ•ˆæ•°æ®"); hideLoading(); return; }

            const width = maxX - minX;
            const height = maxY - minY;
            const maxDim = Math.max(width, height);
            aspectXY = { x: width / maxDim, y: height / maxDim };
            trueZRatio = ((maxZ - minZ) > 0) ? ((maxZ - minZ) / maxDim) : 0.01;

            globalRawData = { points, minX, maxX, minY, maxY, width, height, minZ, maxZ };
            zScaleInput.value = trueZRatio;
            
            globalDelaunay = d3.Delaunay.from(points.map(p => [p.x, p.y]));

            recalcAlphaMesh();
            document.getElementById('btnDownload').disabled = false;
            hideLoading();
        }

        // è®¡ç®— Alpha Mesh (å¸¦å‰¥èš€é€»è¾‘)
        function recalcAlphaMesh() {
            if (!globalRawData || !globalDelaunay) return;
            
            const alpha = parseFloat(alphaInput.value) || 0;
            const radiusLimitSq = alpha > 0 ? (1 / alpha) ** 2 : Infinity;

            const { triangles, halfedges, points: coords } = globalDelaunay;
            const numTriangles = triangles.length / 3;
            
            const removed = new Uint8Array(numTriangles);
            const queue = [];

            // åˆå§‹åŒ–è¾¹ç¼˜é˜Ÿåˆ—
            for (let e = 0; e < halfedges.length; e++) {
                if (halfedges[e] === -1) {
                    queue.push(Math.floor(e / 3));
                }
            }

            let head = 0;
            while(head < queue.length) {
                const t = queue[head++];
                if (removed[t]) continue;

                const i = triangles[3*t], j = triangles[3*t+1], k = triangles[3*t+2];
                const x1 = coords[i*2], y1 = coords[i*2+1];
                const x2 = coords[j*2], y2 = coords[j*2+1];
                const x3 = coords[k*2], y3 = coords[k*2+1];
                
                const a2 = (x1-x2)**2 + (y1-y2)**2;
                const b2 = (x2-x3)**2 + (y2-y3)**2;
                const c2 = (x3-x1)**2 + (y3-y1)**2;
                const area = 0.5 * Math.abs((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1));
                // R^2
                const R2 = (a2*b2*c2) / (16 * area * area);

                // å¦‚æœåŠå¾„è¶…æ ‡ï¼Œç§»é™¤è¯¥è¾¹ç¼˜ä¸‰è§’å½¢ï¼Œå¹¶æš´éœ²å†…éƒ¨
                if (R2 > radiusLimitSq) {
                    removed[t] = 1;
                    for (let m = 0; m < 3; m++) {
                        const e = 3 * t + m;
                        const neighborEdge = halfedges[e];
                        if (neighborEdge !== -1) {
                            const neighborTri = Math.floor(neighborEdge / 3);
                            if (!removed[neighborTri]) queue.push(neighborTri);
                        }
                    }
                }
            }

            const I = [], J = [], K = [];
            for (let t = 0; t < numTriangles; t++) {
                if (!removed[t]) {
                    I.push(triangles[3*t]);
                    J.push(triangles[3*t+1]);
                    K.push(triangles[3*t+2]);
                }
            }

            currentMeshIndices = { I, J, K };
            // ä¸å†éœ€è¦æå–è¾¹ç•Œå¤šè¾¹å½¢äº†
            update3DView(true);
        }

        function update3DView(isNewData = false) {
            if (!globalRawData || !currentMeshIndices) return;
            const p = globalRawData.points;
            const trace = {
                type: 'mesh3d',
                x: p.map(pt => pt.x), y: p.map(pt => pt.y), z: p.map(pt => pt.z),
                i: currentMeshIndices.I, j: currentMeshIndices.J, k: currentMeshIndices.K,
                intensity: p.map(pt => pt.z),
                colorscale: 'Earth', flatshading: chkFlat.checked,
                lighting: { ambient: 0.5, diffuse: 0.8, roughness: 0.1 }
            };
            const layout = {
                margin: { l:0, r:0, b:0, t:0 },
                scene: {
                    aspectmode: 'manual',
                    aspectratio: { x: aspectXY.x, y: aspectXY.y, z: parseFloat(zScaleInput.value) },
                    xaxis: { title: 'X' }, yaxis: { title: 'Y' }, zaxis: { title: 'Height' },
                    camera: { eye: {x: 1.2, y: 1.2, z: 1.2} }
                }
            };
            if (isNewData) Plotly.react('main', [trace], layout, {responsive: true, displayModeBar: false});
            else {
                Plotly.restyle('main', { flatshading: chkFlat.checked });
                Plotly.relayout('main', { 'scene.aspectratio.z': parseFloat(zScaleInput.value) });
            }
        }

        function resetTrueScale() {
            if (!globalRawData) return;
            zScaleInput.value = trueZRatio;
            update3DView(false);
        }

        function downloadContourMap() {
            const btn = document.getElementById('btnDownload');
            const originalText = btn.innerText;
            btn.innerText = "ç”Ÿæˆä¸­..."; btn.disabled = true;
            showLoading("ä¸‰è§’ç½‘æ …æ ¼åŒ–...");

            setTimeout(() => {
                // ä½¿ç”¨ TIN æ …æ ¼åŒ–
                const gridRes = 300; // åˆ†è¾¨ç‡è¶Šé«˜çº¿æ¡è¶Šå¹³æ»‘ï¼Œä½†è®¡ç®—ç¨æ…¢
                const grid = generateGridFromTIN(globalRawData, gridRes, currentMeshIndices);
                
                const mapBaseWidth = 2500; 
                const mapBaseHeight = mapBaseWidth * (globalRawData.height / globalRawData.width);
                const LEGEND_WIDTH = 150;
                const totalExportWidth = mapBaseWidth + LEGEND_WIDTH;

                const contourStart = Math.floor(globalRawData.minZ / 5) * 5;
                const contourEnd = Math.ceil(globalRawData.maxZ / 5) * 5;
                const contourSize = 5; 

                const trace = {
                    type: 'contour',
                    z: grid.z, x: grid.x, y: grid.y,
                    colorscale: 'Earth',
                    zmin: contourStart, zmax: contourEnd, autocolorscale: false,
                    showscale: true,
                    colorbar: {
                        title: 'Height (m)', titleside: 'right',
                        titlefont: { size: 16, family: 'Arial' },
                        tickfont: { size: 14, family: 'Arial' },
                        thickness: 30, len: 1, lenmode: 'fraction', y: 0.5, ypad: 0 
                    },
                    contours: {
                        coloring: 'heatmap', showlabels: true,
                        labelfont: { size: 11, color: 'white' },
                        start: contourStart, end: contourEnd, size: contourSize
                    },
                    line: { width: 0.5, color: 'rgba(255,255,255,0.5)' },
                    connectgaps: false
                };

                const cleanLayout = {
                    title: '', width: totalExportWidth, height: mapBaseHeight,
                    margin: { l: 0, r: LEGEND_WIDTH, b: 0, t: 0 },
                    xaxis: { visible: false, range: [globalRawData.minX, globalRawData.maxX], constrain: 'domain' },
                    yaxis: { visible: false, range: [globalRawData.minY, globalRawData.maxY], scaleanchor: 'x', scaleratio: 1, constrain: 'domain' },
                    paper_bgcolor: 'rgba(255,255,255,0)', plot_bgcolor: 'rgba(255,255,255,0)'
                };

                Plotly.newPlot('hidden-canvas', [trace], cleanLayout).then(gd => {
                    Plotly.downloadImage(gd, {
                        format: 'png', width: totalExportWidth, height: mapBaseHeight,
                        filename: `contour_map_TIN`
                    }).then(() => {
                        btn.innerText = originalText; btn.disabled = false; hideLoading();
                    });
                });
            }, 100);
        }

        // === æ ¸å¿ƒæ›¿æ¢ï¼šTIN æ …æ ¼åŒ–ç®—æ³• ===
        // ç›´æ¥éå†æ‰€æœ‰æœ‰æ•ˆçš„ä¸‰è§’å½¢ï¼Œå¯¹ç½‘æ ¼åƒç´ è¿›è¡Œå¡«å……
        function generateGridFromTIN(data, res, meshIndices) {
            const { points, minX, maxX, minY, maxY, width, height } = data;
            const { I, J, K } = meshIndices;
            
            const stepX = width / (res - 1);
            const stepY = height / (res - 1);
            
            // åˆå§‹åŒ–ç»“æœçŸ©é˜µ (å…¨ null)
            // zMatrix[row][col] -> y=row, x=col
            const zMatrix = new Array(res).fill(null).map(() => new Array(res).fill(null));
            
            // ç”Ÿæˆåæ ‡è½´æ•°ç»„
            const xArr = [], yArr = [];
            for (let i = 0; i < res; i++) {
                xArr.push(minX + i * stepX);
                yArr.push(minY + i * stepY);
            }

            // éå†æ¯ä¸€ä¸ªæœ‰æ•ˆä¸‰è§’å½¢ï¼Œå…‰æ …åŒ–åˆ° Grid ä¸Š
            // è¿™ç§æ–¹æ³•æ¯”éå†æ¯ä¸€ä¸ªåƒç´ å»åˆ¤æ–­åœ¨å“ªä¸ªä¸‰è§’å½¢å†…è¦å¿«å¾—å¤š
            for (let t = 0; t < I.length; t++) {
                const p1 = points[I[t]];
                const p2 = points[J[t]];
                const p3 = points[K[t]];

                // 1. æ‰¾å‡ºè¯¥ä¸‰è§’å½¢åœ¨ Grid ä¸Šçš„åŒ…å›´ç›’ç´¢å¼•
                const triMinX = Math.min(p1.x, p2.x, p3.x);
                const triMaxX = Math.max(p1.x, p2.x, p3.x);
                const triMinY = Math.min(p1.y, p2.y, p3.y);
                const triMaxY = Math.max(p1.y, p2.y, p3.y);

                const idxMinX = Math.max(0, Math.floor((triMinX - minX) / stepX));
                const idxMaxX = Math.min(res - 1, Math.ceil((triMaxX - minX) / stepX));
                const idxMinY = Math.max(0, Math.floor((triMinY - minY) / stepY));
                const idxMaxY = Math.min(res - 1, Math.ceil((triMaxY - minY) / stepY));

                // 2. éå†åŒ…å›´ç›’å†…çš„ Grid ç‚¹
                for (let row = idxMinY; row <= idxMaxY; row++) {
                    const py = yArr[row];
                    for (let col = idxMinX; col <= idxMaxX; col++) {
                        const px = xArr[col];

                        // 3. è®¡ç®—é‡å¿ƒåæ ‡ (Barycentric coordinates)
                        // ç”¨æ¥åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…ï¼Œä»¥åŠè®¡ç®—æ’å€¼é«˜åº¦
                        const det = (p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y);
                        const w1 = ((p2.y - p3.y) * (px - p3.x) + (p3.x - p2.x) * (py - p3.y)) / det;
                        const w2 = ((p3.y - p1.y) * (px - p3.x) + (p1.x - p3.x) * (py - p3.y)) / det;
                        const w3 = 1 - w1 - w2;

                        // å¦‚æœåœ¨ä¸‰è§’å½¢å†… (å…è®¸å¾®å°è¯¯å·®)
                        if (w1 >= -1e-6 && w2 >= -1e-6 && w3 >= -1e-6) {
                            const zVal = w1 * p1.z + w2 * p2.z + w3 * p3.z;
                            zMatrix[row][col] = zVal;
                        }
                    }
                }
            }

            return { x: xArr, y: yArr, z: zMatrix };
        }

        function showLoading(msg) { loadingText.innerText = msg; loadingMask.style.display = 'flex'; }
        function hideLoading() { loadingMask.style.display = 'none'; }
    </script>
</body>
</html>
